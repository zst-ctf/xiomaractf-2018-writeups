//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2018 Retargetable Decompiler <info@retdec.com>
//

#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

// ------------------- Function Prototypes --------------------

int32_t entry_point(int32_t a1, int32_t a2);
int32_t function_80483b8(void);
void function_80483e0(void);
int32_t function_80484c0(void);
int32_t function_80484d0(int32_t a1);
int32_t function_8048500(int32_t a1, int32_t a2);
void (**function_804859b(void))(int32_t);
int32_t function_80485e0(void);
int32_t function_8048619(char * buf);
int32_t function_80486a5(void);
int32_t function_804877a(void);
int32_t function_80487ac(void);
int32_t function_80487e0(int32_t a1, int32_t a2, int32_t a3);
int32_t function_804883d(int32_t a1);
void function_8048844(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // ebp
int32_t g2 = 0; // ebx
int32_t g3 = 0; // edi
int32_t g4 = 0; // esi
char * g5 = "\x1e"; // 0x80488c0
void (**g6)(int32_t) = (void (**)(int32_t))1; // 0x804a060
char g7 = 0; // 0x804a0a8

// ------------------------ Functions -------------------------

// Address range: 0x80483b8 - 0x80483da
int32_t function_80483b8(void) {
    int32_t result = *(int32_t *)(function_80484c0() + 0x1c3b); // 0x80483c7
    if (result != 0) {
        // 0x80483d1
        __gmon_start();
        // branch -> 0x80483d6
    }
    // 0x80483d6
    int32_t v1;
    g2 = v1;
    return result;
}

// Address range: 0x80483e0 - 0x804848f
void function_80483e0(void) {
    // 0x80483e0
    return;
}

// Address range: 0x8048490 - 0x80484bf
int32_t entry_point(int32_t a1, int32_t a2) {
    int32_t v1;
    g4 = v1;
    int32_t result = __libc_start_main((int32_t * (*)(int32_t, char **, char **))function_80487ac, v1, (char **)&a1, (void (**)())function_80487e0, (void (**)())0x8048840, (void (**)())0); // 0x80484ac
    return result;
}

// Address range: 0x80484c0 - 0x80484cf
int32_t function_80484c0(void) {
    // 0x80484c0
    int32_t result;
    return result;
}

// Address range: 0x80484d0 - 0x80484ff
int32_t function_80484d0(int32_t a1) {
    // 0x80484d0
    return 3;
}

// Address range: 0x8048500 - 0x804859a
int32_t function_8048500(int32_t a1, int32_t a2) {
    // 0x8048500
    return (int32_t)(((int32_t)(char)&g7 - 0x804a0a8 >> 2) + ((int32_t)(char)&g7 - 0x804a0a8 >> 2) / 0x80000000) >> 1;
}

// Address range: 0x804859b - 0x80485df
void (**function_804859b(void))(int32_t) {
    // 0x804859b
    g6 = NULL;
    signal(SIGTRAP, 0x804858b);
    raise(5);
    signal(SIGTRAP, SIG_IGN);
    return g6;
}

// Address range: 0x80485e0 - 0x8048618
int32_t function_80485e0(void) {
    // 0x80485e0
    int32_t result;
    if (ptrace(0) != -1) {
        // 0x8048602
        ptrace(17);
        result = 0;
        // branch -> 0x8048617
    } else {
        result = 1;
    }
    // 0x8048617
    int32_t v1;
    g1 = v1;
    return result;
}

// Address range: 0x8048619 - 0x80486a4
int32_t function_8048619(char * buf) {
    int32_t v1 = rand(); // 0x804861f
    int32_t v2 = 0;
    char * v3 = (char *)((int32_t)buf + v2);
    *v3 = (char)((int32_t)*v3 + v1 + -10 * v1 / 10);
    int32_t v4 = v2 + 1; // 0x8048676
    // branch -> 0x804865a
    while (v4 < 38) {
        // 0x804865a
        v2 = v4;
        v3 = (char *)((int32_t)buf + v2);
        *v3 = (char)((int32_t)*v3 + v1 + -10 * v1 / 10);
        v4 = v2 + 1;
        // continue -> 0x804865a
    }
    // 0x8048680
    write(0, buf, 39);
    return puts("\n");
}

// Address range: 0x80486a5 - 0x8048779
int32_t function_80486a5(void) {
    int32_t v1 = *(int32_t *)20; // 0x80486b2
    int32_t v2;
    memcpy((char *)&v2, (char *)&g5, 39);
    if (function_80485e0() != 0) {
        // 0x80486dd
        puts("Are u kidding me ");
        puts("Running a ptrace wont give u flag ...");
        exit(0);
        // UNREACHABLE
    }
    // 0x8048746
    int32_t v3;
    int32_t v4 = &v3; // 0x8048732_0
    // branch -> 0x8048713
    for (int32_t i = 0; i < 39; i++) {
        unsigned char v5 = *(char *)(i + (int32_t)"flag{this_is_a_fake_flag_dig_deeper_:(}"); // 0x804871e
        int32_t v6 = *(int32_t *)(4 * i - 236 + g1); // 0x8048727
        *(char *)(i + v4) = (char)(v6 ^ (int32_t)v5);
        // continue -> 0x8048713
    }
    // 0x804874f
    function_8048619((char *)&v3);
    int32_t v7 = *(int32_t *)20; // 0x8048765
    if (v7 != v1) {
        // 0x804876d
        __stack_chk_fail();
        // branch -> 0x8048772
    }
    // 0x8048772
    return v7 ^ v1;
}

// Address range: 0x804877a - 0x80487ab
int32_t function_804877a(void) {
    void (**v1)(int32_t) = function_804859b(); // 0x8048780
    int32_t puts_rc = (int32_t)v1; // 0x80487ab_2
    if (v1 == NULL) {
        // 0x8048789
        puts(" BOOOooooooooMMMMM ");
        puts_rc = puts(" No Breakpoints any more !!!!!");
        // branch -> 0x80487a9
    }
    // 0x80487a9
    return puts_rc;
}

// Address range: 0x80487ac - 0x80487df
int32_t function_80487ac(void) {
    // 0x80487ac
    function_804877a();
    puts("your flag is :");
    return 0;
}

// Address range: 0x80487e0 - 0x804883c
int32_t function_80487e0(int32_t a1, int32_t a2, int32_t a3) {
    // 0x80487e0
    g3 = 0;
    int32_t v1 = function_80484c0(); // 0x80487e6
    g1 = a1;
    function_80483b8();
    int32_t v2 = g2; // 0x8048803
    int32_t result = v2 - 252; // 0x8048803
    int32_t v3 = v1 + 0x171d - result; // 0x8048809
    g4 = v3 / 4;
    if (v3 < 4) {
        // 0x8048835
        return result;
    }
    // 0x8048818
    ((int32_t (*)(int32_t, int32_t))*(int32_t *)(v2 - 252 + 4 * g3))(a2, a3);
    int32_t v4 = g3 + 1; // 0x804882b
    g3 = v4;
    // branch -> 0x8048818
    while (v4 != g4) {
        // 0x8048818
        // 0x8048818
        ((int32_t (*)(int32_t, int32_t))*(int32_t *)(g2 - 252 + 4 * v4))(a2, a3);
        v4 = g3 + 1;
        g3 = v4;
        // branch -> 0x8048818
    }
    // 0x8048835
    return result;
}

// Address range: 0x804883d - 0x8048841
int32_t function_804883d(int32_t a1) {
    // 0x804883d
    return g4;
}

// Address range: 0x8048844 - 0x8048857
void function_8048844(void) {
    // 0x8048844
    function_80484c0();
}

// --------------- Dynamically Linked Functions ---------------

// void __gmon_start(void);
// int __libc_start_main(int *(main)(int, char **, char **), int argc, char ** ubp_av, void(* init)(void), void(* fini)(void), void(* rtld_fini)(void), void(* stack_end));
// void __stack_chk_fail(void);
// void exit(int status);
// long int ptrace(enum __ptracerequest __request, ...);
// int puts(const char * s);
// int raise(int sig);
// int rand(void);
// __sighandler_t signal(int sig, __sighandler_t handler);
// ssize_t write(int fd, const void * buf, size_t n);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (5.1.1)
// Detected functions: 15
// Decompiler release: v2.2.1 (2016-09-07)
// Decompilation date: 2018-02-23 15:43:48
